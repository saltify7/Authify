import type { DefineAPI, SDK } from "caido:plugin";

// Result type for safe error handling between backend and frontend
export type Result<T> =
  | { kind: "Error"; error: string }
  | { kind: "Ok"; value: T };

// Filter settings type
export type FilterSettings = {
  ignoreStyling: boolean;
  ignoreJavaScript: boolean;
  ignoreImages: boolean;
  ignoreOptions: boolean;
};

// Filter settings state
let filterSettings: FilterSettings = {
  ignoreStyling: true,
  ignoreJavaScript: true,
  ignoreImages: true,
  ignoreOptions: true
};

// Function to get filter settings
export const getFilterSettings = (sdk: SDK): Result<FilterSettings> => {
  return { kind: "Ok", value: { ...filterSettings } };
};

// Function to set filter settings
export const setFilterSettings = (sdk: SDK, settings: FilterSettings): Result<void> => {
  filterSettings = { ...settings };
  sdk.console.log(`Filter settings updated: styling=${filterSettings.ignoreStyling}, js=${filterSettings.ignoreJavaScript}, images=${filterSettings.ignoreImages}, options=${filterSettings.ignoreOptions}`);
  return { kind: "Ok", value: undefined };
};

// Check if a request should be filtered out based on file extensions and HTTP methods
export const shouldFilterRequest = (req: any): boolean => {
  const method = req.getMethod();
  const path = req.getPath();
  
  // Check OPTIONS method filter
  if (filterSettings.ignoreOptions && method.toUpperCase() === 'OPTIONS') {
    return true;
  }
  
  // Extract file extension from path
  const pathParts = path.split('.');
  if (pathParts.length < 2) {
    return false; // No extension, don't filter
  }
  
  const extension = pathParts[pathParts.length - 1].toLowerCase();
  
  // Check styling files
  if (filterSettings.ignoreStyling) {
    const stylingExtensions = ['css', 'scss', 'sass', 'less', 'woff', 'woff2', 'ttf', 'otf', 'eot'];
    if (stylingExtensions.includes(extension)) {
      return true;
    }
  }
  
  // Check JavaScript files
  if (filterSettings.ignoreJavaScript) {
    const jsExtensions = ['js', 'js.map', 'mjs', 'ts', 'tsx', 'jsx'];
    if (jsExtensions.includes(extension)) {
      return true;
    }
  }
  
  // Check image files
  if (filterSettings.ignoreImages) {
    const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp', 'ico', 'bmp', 'tiff'];
    if (imageExtensions.includes(extension)) {
      return true;
    }
  }
  
  return false;
};

// Check if a request is plugin-generated by looking for the first stored header in the raw request
export const isPluginGeneratedRequest = (sdk: SDK, req: any, storedAuthHeaders: string): boolean => {
  // Check if we have any stored auth headers
  if (!storedAuthHeaders.trim()) {
    return false;
  }
  
  // Get the first stored header line
  const authLines = storedAuthHeaders.split('\n').filter(line => line.trim());
  if (authLines.length === 0) {
    return false;
  }
  
  const firstHeader = authLines[0]?.trim();
  if (!firstHeader) {
    return false;
  }
  
  // Get the raw request body
  const rawRequest = req.getRaw()?.toText() ?? "";
  
  // Check if the first header appears in the raw request
  if (rawRequest.includes(firstHeader)) {
    sdk.console.log(`Found plugin-generated request marker in raw request: ${firstHeader}`);
    return true;
  }
  
  return false;
};

// Export API type for filter functions
export type FilterAPI = DefineAPI<{
  getFilterSettings: typeof getFilterSettings;
  setFilterSettings: typeof setFilterSettings;
}>;
